# nest-tree
Construction of component framework
这是一款组件化脚手架，持续更新中...

# 首先先弄清楚什么是"组件"和"模块"

组件：指的是单一的功能组件，地图组件、支付组件、分享组件等功能；
(把重复的代码提取出来合并成为一个个组件，组件最重要的就是重用（复用），位于框架最底层，其他功能都依赖于组件，可供不同功能使用，独立性强。)

模块：指的是独立的业务模块，如首页模块、聊天模块、播放模块等，模块相对于组件来说粒度更大。
(分属同一功能/业务的代码进行隔离（分装）成独立的模块，可以独立运行，以页面、功能或其他不同粒度划分程度不同的模块，位于业务框架层，模块间通过接口调用，目的是降低模块间的耦合，由之前的主应用与模块耦合，变为主应用与接口耦合，接口与模块耦合。)
(模块就像有多个USB插口的充电宝，可以和多部手机充电，接口可以随意插拔。复用性很强，可以独立管理。)

# 团队开发讲究"约定大于配置" 组件间的关系都要严格遵守一个准则：编"译器隔离，运行期按需依赖"。

# 本脚手架的贯穿的思想是 (隔离/封装)高内聚性, 低耦合 单独调试 和 简单的集成调试 完结，接下来更多的就是 集成调试情况下，如何保证组件在高度聚合的情况下互通有无。

# 本脚手架遵循了软件开发的六大设计原则

#开闭原则
对扩展开放，对修改关闭。其目的在于当我们需要拓展一个功能的时候，不能去修改原有的代码，而应该去通过其它的方法来达到这个目的，其实此处的其它方法，便是针对代码中容易发生改动的位子，利用接口或抽象类来进行拓展，在需要改动的时候，只需要根据需求重新派生一个新的实现类就可以了。

#里氏代换原则
任何基类可以出现的地方，子类一定可以出现。这就要求，子类可以实现父类中的抽象方法，但不要覆盖父类已实现的方法。如果随意修改了父类已实现的方法，可能会带来未知的错误。

#依赖倒置原则
高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：面向接口编程

#单一职责
一个对象，一个模块功能应该是单一的，不应该承担太多的职责，也就是术业有专攻。

#接口隔离原则
客户端不应该依赖它不需要的接口
类间的依赖关系应该建立在最小的接口上

如果一个类实现一个接口，但这个接口中有它不需要的方法，那么就需要把这个接口拆分，把它需要的方法提取出来，组成一个新的接口让这个类去实现，这就是接口隔离原则。简而言之，就是说，接口中的所有方法对其实现的子类都是有用的。否则，就将接口继续细分。

#迪米特法则
也叫最少知道原则(Least Knowledge Principle)一个类应该对其它的对象有最少的了解。

从依赖者的角度来说，只依赖其应该依赖的对象
从被依赖者的角度来讲，只暴露该暴露的方法

#合成复用原则
在软件设计的时候应该优先采用组合，其次才考虑使用继承关系
软件开发的六大设计原则从一个高维度进行指导软件开发的实践，为开发可维护，高拓展性软件提供方法论。





#app壳工程
app壳没有任何功能主要就是集成每个业务组件，最终打包成一个完整的APK

#business 功能组件

#function 业务组件



组件间的通信主要包括两方面的内容:
一种是业务之间的通知消息====>可以采用EventBus,RxBus这种消息总线来做
另一个通信则是组件间基础数据的打通====>可以采用EventBus,RxBus这种消息总线来做

#命名规范
整个项目的命名规则是根据"camelCase"(https://baike.baidu.com/item/camelCase/636859?fr=aladdin)演化而来
 

#icon
ic_+模块名称+具体的功能(phone、email等等)

#package
包名全部小写，不允许出现中文、大写字母或者下划线，前面为子模块命名，



#xml
主要是配置 
resourcePrefix "xxx_"


#你想要的Android性能优化系列：启动优化 ！
https://juejin.cn/post/6854573215474253838

#Android线上轻量级APM性能监测方案
https://juejin.cn/post/6872151038305140744

#性能检测库
https://github.com/XanderWang/performance


#常用命令:
编译耗时检测:
./gradlew assembleDebug --profile
命令查看应用启动时间
adb shell am start-W 包名/启动类具体路径 


#基于apt的启动期
注解及参数说明:
@Starter  标注启动管理类
mainProcessOnly -- 是否只在主进程初始化 true 只在主进程中初始化 false 所有进程都进行初始化

@StarterMethod 标注启动方法，只能用到@Starter修饰的类中，否则无效。
priority -- 该启动方法的优先级，[0-99],数值越大优先级越高，默认50；
isSync -- 是否同步初始化（即在主线程中进行初始化操作），true 是 false 不是，即可以在子线程中进行初始化，默认true；
isDelay -- 是否可以延迟初始化，true 是 false 不是，立即初始化，不延迟，默认false；

@StarterFinish 启动方法的监听方法，只能用到@Starter修饰的类中，否则无效。
listen -- 要监听方法的方法名，必填参数；


# Multidex预加载优化
抖音BoostMultiDex优化实践:
5.0以上默认使用ART，在安装时已将Class.dex转换为oat文件了，无需优化，所以应判断只有在主进程及SDK 5.0以下才进行Multidex的预加载


#tombstones 


#Android 流量统计
利用Android 系统提供的TrafficStats 

android.net.TrafficStats


#流畅度监测原理 
Android 系统每隔16.6ms 发出VSYNC 信号，来通知界面进行输入、动画、绘制等功能，每一次同步的周期为16.6ms 代表刷新频率为16.6ms 及来回两次回调 原理可以查询Choreographer


#gradle.properties中配置的属性
执行:./gradlew properties
注意：在gradle.properties中定义的属性默认是String类型的，如果需要int类型，需要添加XXX as int后缀。

# gradle 常用调试参数
--quiet 仅显示error信息；
--warn 显示warn级别及以上的信息；
--info   显示info级别及以上的信息；
--debug 显示debug级别及以上的信息；
--stacktrace 显示exception堆栈的详细信息。





#三级测试
组件单元提测（组件开发好后需要该组件的开发人员对组件进行自测）
组件主工程提测 （自测没有大问题后，可以通知开发过该业务的人需要进行一轮测试）
版本提测（依赖测试人员进行回归测试）


